import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import {
  CanvasNode,
  CanvasEdge,
  Viewport,
  SelectedPath,
  Snapshot,
  LoadingState,
  ErrorState,
  CanvasConfig,
  NodeContext,
  AILevel,
  AIAnalysisResult,
  KeywordNodeData
} from '@/types/canvas';
// AI ËæÖÂä©ÂáΩÊï∞
const analyzeUserInput = async (userInput: string) => {
  // Ê®°ÊãüAIÂàÜÊûêÁªìÊûú
  return {
    levelCount: 3,
    levels: [
      { level: 1, label: 'L1', description: 'Ë°®Â±ÇÊé¢Á¥¢', isActive: true, nodeCount: 2 },
      { level: 2, label: 'L2', description: 'ÂÖ∑‰ΩìÂéüÂõ†', isActive: false, nodeCount: 0 },
      { level: 3, label: 'L3', description: 'Ëß£ÂÜ≥ÊñπÊ°à', isActive: false, nodeCount: 0 }
    ],
    initialNodes: [
      { level: 1, content: 'ÈóÆÈ¢òÁöÑË°®Èù¢Áé∞Ë±°', hasChildren: true },
      { level: 1, content: 'Áõ∏ÂÖ≥ÂΩ±ÂìçÂõ†Á¥†', hasChildren: true }
    ],
    originalPrompt: userInput
  };
};

const expandNodeContent = async (
  nodeContent: string,
  nodeLevel: number,
  parentContext: string,
  userPrompt: string
) => {
  // ‰ΩøÁî®ÂèÇÊï∞ÈÅøÂÖçÊú™‰ΩøÁî®Ë≠¶Âëä
  console.log('Expanding node:', { nodeContent, nodeLevel, parentContext, userPrompt });
  // Ê®°ÊãüËäÇÁÇπÊâ©Â±ïÁªìÊûú
  return {
    children: [
      { content: `${nodeContent} - Â≠êÈ°π1`, level: nodeLevel + 1, hasChildren: true },
      { content: `${nodeContent} - Â≠êÈ°π2`, level: nodeLevel + 1, hasChildren: true }
    ]
  };
};

const generateChatBotResponse = (levelCount: number): string => {
  return `Â∑≤Ê†πÊçÆÂÖ≥ÈîÆËØç‰∏∫ÊÇ®ÂáÜÂ§áÂ•Ω${levelCount}‰∏™Â±ÇÁ∫ßÁöÑÂü∫Á°ÄÊûÑÂª∫Ê®°ÂûãÔºåÊÇ®ÂèØÊ†πÊçÆÈúÄÊ±ÇË∞ÉÊï¥ÁîüÊàêÁöÑÂ±ÇÁ∫ß„ÄÇÁÇπÂáªÁÆ≠Â§¥‰ª•ÁîüÊàê‰∏ã‰∏ÄÁ∫ßÂÜÖÂÆπ„ÄÇ`;
};

const getNodeBackgroundColor = (level: number): string => {
  if (level === 0) return '#161618'; // ÂéüÂßãÂÜÖÂÆπ
  return level % 2 === 1 ? '#262627' : '#161618';
};

interface CanvasStore {
  // Ê†∏ÂøÉÊï∞ÊçÆ
  nodes: CanvasNode[];
  edges: CanvasEdge[];
  viewport: Viewport;
  selectedPath: SelectedPath | null;

  // AIÁõ∏ÂÖ≥Áä∂ÊÄÅ
  levels: AILevel[];
  currentLevel: number;
  originalPrompt: string;
  isAIGenerating: boolean;

  // ÁâàÊú¨ÁÆ°ÁêÜ
  snapshots: Snapshot[];
  currentSnapshotId: string | null;

  // UI Áä∂ÊÄÅ
  loading: LoadingState;
  error: ErrorState | null;
  config: CanvasConfig;
  
  // Âü∫Á°ÄÊìç‰Ωú
  setNodes: (nodes: CanvasNode[]) => void;
  setEdges: (edges: CanvasEdge[]) => void;
  setViewport: (viewport: Viewport) => void;
  
  // ËäÇÁÇπÊìç‰Ωú
  addNode: (node: CanvasNode) => void;
  updateNode: (nodeId: string, updates: Partial<CanvasNode>) => void;
  deleteNode: (nodeId: string) => void;
  
  // ËæπÊìç‰Ωú
  addEdge: (edge: CanvasEdge) => void;
  deleteEdge: (edgeId: string) => void;
  
  // Ë∑ØÂæÑÈÄâÊã©
  selectPath: (nodeIds: string[]) => void;
  clearSelection: () => void;

  // AIÂ±ÇÁ∫ßÁÆ°ÁêÜ
  analyzeUserInput: (userInput: string) => Promise<string>;
  setLevels: (levels: AILevel[]) => void;
  setCurrentLevel: (level: number) => void;
  updateLevelNodeCount: (level: number, count: number) => void;

  // AI ÁîüÊàêÁõ∏ÂÖ≥
  generateChildren: (nodeId: string, context: NodeContext) => Promise<void>;
  renewNode: (nodeId: string, context: NodeContext) => Promise<void>;
  generateInitialNodes: (analysisResult: AIAnalysisResult) => void;
  
  // ÁâàÊú¨ÁÆ°ÁêÜ
  saveSnapshot: (name: string, description?: string) => Promise<void>;
  loadSnapshot: (snapshotId: string) => void;
  deleteSnapshot: (snapshotId: string) => void;
  
  // ÈîôËØØÂ§ÑÁêÜ
  setError: (error: ErrorState | null) => void;
  clearError: () => void;
  
  // Âä†ËΩΩÁä∂ÊÄÅ
  setLoading: (loading: Partial<LoadingState>) => void;
  
  // ÈáçÁΩÆ
  reset: () => void;
}

const defaultViewport: Viewport = { x: 0, y: 0, zoom: 1 };

const defaultConfig: CanvasConfig = {
  maxZoom: 2,
  minZoom: 0.1,
  defaultViewport,
  nodeSpacing: {
    horizontal: 200,
    vertical: 100,
  },
  autoLayout: {
    direction: 'TB',
    rankSeparation: 100,
    nodeSeparation: 200,
  },
};

const defaultLoadingState: LoadingState = {
  isGenerating: false,
  renewingNodeId: null,
  isSaving: false,
  isLoading: false,
};

export const useCanvasStore = create<CanvasStore>()(
  immer((set) => ({
    // ÂàùÂßãÁä∂ÊÄÅ
    nodes: [],
    edges: [],
    viewport: defaultViewport,
    selectedPath: null,

    // AIÁõ∏ÂÖ≥ÂàùÂßãÁä∂ÊÄÅ
    levels: [],
    currentLevel: 1,
    originalPrompt: '',
    isAIGenerating: false,

    snapshots: [],
    currentSnapshotId: null,
    loading: defaultLoadingState,
    error: null,
    config: defaultConfig,

    // Âü∫Á°ÄÊìç‰Ωú
    setNodes: (nodes) => set((state) => {
      state.nodes = nodes;
    }),

    setEdges: (edges) => set((state) => {
      state.edges = edges;
    }),

    setViewport: (viewport) => set((state) => {
      state.viewport = viewport;
    }),

    // ËäÇÁÇπÊìç‰Ωú
    addNode: (node) => set((state) => {
      state.nodes.push(node);
    }),

    updateNode: (nodeId, updates) => set((state) => {
      const nodeIndex = state.nodes.findIndex(n => n.id === nodeId);
      if (nodeIndex !== -1) {
        state.nodes[nodeIndex] = { ...state.nodes[nodeIndex], ...updates };
      }
    }),

    deleteNode: (nodeId) => set((state) => {
      state.nodes = state.nodes.filter(n => n.id !== nodeId);
      state.edges = state.edges.filter(e => e.source !== nodeId && e.target !== nodeId);
    }),

    // ËæπÊìç‰Ωú
    addEdge: (edge) => set((state) => {
      state.edges.push(edge);
    }),

    deleteEdge: (edgeId) => set((state) => {
      state.edges = state.edges.filter(e => e.id !== edgeId);
    }),

    // Ë∑ØÂæÑÈÄâÊã©
    selectPath: (nodeIds) => set((state) => {
      const nodes = nodeIds.map(id => state.nodes.find(n => n.id === id)).filter(Boolean) as CanvasNode[];
      state.selectedPath = {
        nodeIds,
        nodes,
        isComplete: nodes.length === nodeIds.length,
      };
    }),

    clearSelection: () => set((state) => {
      state.selectedPath = null;
    }),

    // AIÂ±ÇÁ∫ßÁÆ°ÁêÜ
    analyzeUserInput: async (userInput: string) => {
      console.log('üè™ Store analyzeUserInput called with:', userInput);

      set((state) => {
        state.isAIGenerating = true;
        state.originalPrompt = userInput;
      });

      try {
        console.log('üîÑ Calling local analyzeUserInput function...');
        const analysisResult = await analyzeUserInput(userInput);
        console.log('üìä Analysis result:', analysisResult);

        set((state) => {
          // ËÆæÁΩÆÂ±ÇÁ∫ß‰ø°ÊÅØ
          state.levels = analysisResult.levels.map((level: {
            level: number;
            label: string;
            description: string;
            isActive: boolean;
            nodeCount: number;
          }) => ({
            ...level,
            isActive: level.level === 1,
            nodeCount: level.level === 1 ? analysisResult.initialNodes.length : 0
          }));

          state.currentLevel = 1;
        });

        // ÁîüÊàêÂàùÂßãËäÇÁÇπ
        set((state) => {
          state.nodes = analysisResult.initialNodes.map((nodeData: {
            content: string;
            level: number;
            hasChildren: boolean;
          }, index: number) => ({
            id: `node-${Date.now()}-${index}`,
            type: 'keyword' as const,
            position: { x: index * 250, y: 100 },
            data: {
              id: `node-${Date.now()}-${index}`,
              content: nodeData.content,
              level: nodeData.level,
              type: 'keyword' as const,
              canExpand: nodeData.hasChildren,
              hasChildren: nodeData.hasChildren,
              isGenerating: false,
              isSelected: false,
            } as KeywordNodeData,
            style: {
              backgroundColor: getNodeBackgroundColor(nodeData.level),
            }
          }));
        });

        return generateChatBotResponse(analysisResult.levelCount);

      } catch (error) {
        set((state) => {
          state.error = {
            message: error instanceof Error ? error.message : 'AI analysis failed',
            type: 'generation',
            timestamp: new Date(),
          };
        });
        throw error;
      } finally {
        set((state) => {
          state.isAIGenerating = false;
        });
      }
    },

    setLevels: (levels) => set((state) => {
      state.levels = levels;
    }),

    setCurrentLevel: (level) => set((state) => {
      state.currentLevel = level;
      // Êõ¥Êñ∞Â±ÇÁ∫ßÊøÄÊ¥ªÁä∂ÊÄÅ
      state.levels.forEach(l => {
        l.isActive = l.level === level;
      });
    }),

    updateLevelNodeCount: (level, count) => set((state) => {
      const levelIndex = state.levels.findIndex(l => l.level === level);
      if (levelIndex !== -1) {
        state.levels[levelIndex].nodeCount = count;
      }
    }),

    generateInitialNodes: (analysisResult) => set((state) => {
      // Ê∏ÖÁ©∫Áé∞ÊúâËäÇÁÇπ
      state.nodes = [];
      state.edges = [];

      // ÁîüÊàêÂàùÂßãËäÇÁÇπ
      state.nodes = analysisResult.initialNodes.map((nodeData: {
        content: string;
        level: number;
        hasChildren: boolean;
      }, index: number) => ({
        id: `node-${Date.now()}-${index}`,
        type: 'keyword' as const,
        position: { x: index * 250, y: 100 },
        data: {
          id: `node-${Date.now()}-${index}`,
          content: nodeData.content,
          level: nodeData.level,
          type: 'keyword' as const,
          canExpand: nodeData.hasChildren,
          hasChildren: nodeData.hasChildren,
          isGenerating: false,
          isSelected: false,
        } as KeywordNodeData,
        style: {
          backgroundColor: getNodeBackgroundColor(nodeData.level),
        }
      }));
    }),

    // AI ÁîüÊàêÁõ∏ÂÖ≥ (Âç†‰ΩçÁ¨¶ÂÆûÁé∞)
    generateChildren: async (nodeId, context) => {
      set((state) => {
        state.loading.isGenerating = true;
        // Êõ¥Êñ∞ËäÇÁÇπÁîüÊàêÁä∂ÊÄÅ
        const nodeIndex = state.nodes.findIndex(n => n.id === nodeId);
        if (nodeIndex !== -1 && state.nodes[nodeIndex].data) {
          state.nodes[nodeIndex].data.isGenerating = true;
        }
      });

      try {
        const parentNode = useCanvasStore.getState().nodes.find(n => n.id === nodeId);
        if (!parentNode || !parentNode.data) {
          throw new Error('Parent node not found');
        }

        const expansionResult = await expandNodeContent(
          parentNode.data.content,
          parentNode.data.level,
          context.parentContent || '',
          useCanvasStore.getState().originalPrompt
        );

        set((state) => {
          const parentNodeIndex = state.nodes.findIndex(n => n.id === nodeId);
          if (parentNodeIndex === -1) return;

          const parentNode = state.nodes[parentNodeIndex];
          const childLevel = parentNode.data.level + 1;

          // ÁîüÊàêÂ≠êËäÇÁÇπ
          const childNodes = expansionResult.children.map((childData: {
            content: string;
            level: number;
            hasChildren: boolean;
          }, index: number) => ({
            id: `${nodeId}-child-${Date.now()}-${index}`,
            type: 'keyword' as const,
            position: {
              x: parentNode.position.x + (index - expansionResult.children.length / 2) * 200,
              y: parentNode.position.y + 150
            },
            data: {
              id: `${nodeId}-child-${Date.now()}-${index}`,
              content: childData.content,
              level: childLevel,
              parentId: nodeId,
              type: 'keyword' as const,
              canExpand: childData.hasChildren,
              hasChildren: childData.hasChildren,
              isGenerating: false,
              isSelected: false,
            } as KeywordNodeData,
            style: {
              backgroundColor: getNodeBackgroundColor(childLevel),
            }
          }));

          // Ê∑ªÂä†Â≠êËäÇÁÇπÂà∞ÁîªÂ∏É
          state.nodes.push(...childNodes);

          // ÂàõÂª∫ËøûÊé•Ëæπ
          const childEdges = childNodes.map((childNode: CanvasNode) => ({
            id: `edge-${nodeId}-${childNode.id}`,
            source: nodeId,
            target: childNode.id,
            type: 'default' as const,
          }));

          state.edges.push(...childEdges);

          // Êõ¥Êñ∞Â±ÇÁ∫ßËäÇÁÇπÊï∞Èáè
          const levelIndex = state.levels.findIndex(l => l.level === childLevel);
          if (levelIndex !== -1) {
            state.levels[levelIndex].nodeCount += childNodes.length;
          }

          // Êõ¥Êñ∞Áà∂ËäÇÁÇπÁä∂ÊÄÅ
          if (state.nodes[parentNodeIndex].data) {
            state.nodes[parentNodeIndex].data.isGenerating = false;
            state.nodes[parentNodeIndex].data.hasChildren = true;
          }
        });

      } catch (error) {
        set((state) => {
          state.error = {
            message: error instanceof Error ? error.message : 'Generation failed',
            type: 'generation',
            nodeId,
            timestamp: new Date(),
          };

          // ÈáçÁΩÆËäÇÁÇπÁîüÊàêÁä∂ÊÄÅ
          const nodeIndex = state.nodes.findIndex(n => n.id === nodeId);
          if (nodeIndex !== -1 && state.nodes[nodeIndex].data) {
            state.nodes[nodeIndex].data.isGenerating = false;
          }
        });
      } finally {
        set((state) => {
          state.loading.isGenerating = false;
        });
      }
    },

    renewNode: async (nodeId, context) => {
      set((state) => {
        state.loading.renewingNodeId = nodeId;
      });
      
      try {
        // TODO: ÂÆûÁé∞ÂÆûÈôÖÁöÑËäÇÁÇπÊõ¥Êñ∞ÈÄªËæë
        console.log('Renewing node:', nodeId, context);
        
        // Ê®°ÊãüÂºÇÊ≠•Êìç‰Ωú
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        set((state) => {
          state.error = {
            message: error instanceof Error ? error.message : 'Renewal failed',
            type: 'generation',
            nodeId,
            timestamp: new Date(),
          };
        });
      } finally {
        set((state) => {
          state.loading.renewingNodeId = null;
        });
      }
    },

    // ÁâàÊú¨ÁÆ°ÁêÜ
    saveSnapshot: async (name, description) => {
      set((state) => {
        state.loading.isSaving = true;
      });

      try {
        set((state) => {
          const snapshot: Snapshot = {
            id: `snapshot-${Date.now()}`,
            name,
            description,
            nodes: [...state.nodes],
            edges: [...state.edges],
            viewport: { ...state.viewport },
            selectedPath: state.selectedPath ? { ...state.selectedPath } : undefined,
            createdAt: new Date(),
            updatedAt: new Date(),
          };

          state.snapshots.push(snapshot);
          state.currentSnapshotId = snapshot.id;
        });
        
      } catch (error) {
        set((state) => {
          state.error = {
            message: error instanceof Error ? error.message : 'Save failed',
            type: 'storage',
            timestamp: new Date(),
          };
        });
      } finally {
        set((state) => {
          state.loading.isSaving = false;
        });
      }
    },

    loadSnapshot: (snapshotId) => set((state) => {
      const snapshot = state.snapshots.find(s => s.id === snapshotId);
      if (snapshot) {
        state.nodes = [...snapshot.nodes];
        state.edges = [...snapshot.edges];
        state.viewport = { ...snapshot.viewport };
        state.selectedPath = snapshot.selectedPath ? { ...snapshot.selectedPath } : null;
        state.currentSnapshotId = snapshotId;
      }
    }),

    deleteSnapshot: (snapshotId) => set((state) => {
      state.snapshots = state.snapshots.filter(s => s.id !== snapshotId);
      if (state.currentSnapshotId === snapshotId) {
        state.currentSnapshotId = null;
      }
    }),

    // ÈîôËØØÂ§ÑÁêÜ
    setError: (error) => set((state) => {
      state.error = error;
    }),

    clearError: () => set((state) => {
      state.error = null;
    }),

    // Âä†ËΩΩÁä∂ÊÄÅ
    setLoading: (loading) => set((state) => {
      state.loading = { ...state.loading, ...loading };
    }),

    // ÈáçÁΩÆ
    reset: () => set((state) => {
      state.nodes = [];
      state.edges = [];
      state.viewport = defaultViewport;
      state.selectedPath = null;

      // ÈáçÁΩÆAIÁõ∏ÂÖ≥Áä∂ÊÄÅ
      state.levels = [];
      state.currentLevel = 1;
      state.originalPrompt = '';
      state.isAIGenerating = false;

      state.loading = defaultLoadingState;
      state.error = null;
    }),
  }))
);
